<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=#000000 id=color_chrome name=theme-color><meta content=#000000 id=color_safari name=apple-mobile-web-app-status-bar-style><meta content="Jam's Blog" name=description><link rel="Shortcut Icon" href=https://blog.fullstackjam.dev/favicon.svg><link href=https://blog.fullstackjam.dev/favicon.svg rel=Bootmark><link title="Jam's Blog" href=https://blog.fullstackjam.dev/rss.xml rel=alternate type=application/rss+xml><style>#title,body{line-height:1.6em}body{background:#000;color:#00c000;font-size:1.2em}#container{margin:2.4em auto;width:72%}#header{text-align:center}#header>a{font-size:.96em;margin:auto 1em}#title{font-size:1.6em;font-weight:700;margin:1em auto}#date{font-style:italic}#list>li{margin:.8em auto;list-style:disc}img{max-width:100%}a{color:inherit;text-decoration:none}#content a,a:hover{text-decoration:underline}pre{padding:1em;overflow:auto;background:#1b1d16}:not(pre) >code{padding:.2em;background:#1b1d16;overflow:auto}blockquote{padding:0 1em;margin:0;border-left:.25em solid #212121}@media (max-width:600px){#container{width:88%}#header>a{margin:auto .3em}}</style><title>使用 Pydantic 统一 Python 和 RESTful API 的命名规范 - Jam's Blog</title><body><div id=header><a href=https://blog.fullstackjam.dev>Jam's Blog</a><a href=https://blog.fullstackjam.dev/about/>About</a><a href=https://blog.fullstackjam.dev/friends/>Friends</a><a href=https://blog.fullstackjam.dev/projects/>Projects</a></div><div id=container><a href=https://blog.fullstackjam.dev/2025/shi-yong-pydantic-tong-yi-python-he-restful-api-de-ming-ming-gui-fan/ id=title>使用 Pydantic 统一 Python 和 RESTful API 的命名规范</a><div id=date>2025-02-05</div><div id=content><p>在现代 Web 开发中，API 风格和命名规范是确保前后端顺畅协作的重要方面。尤其是前后端分离的架构，前端通常使用 <code>camelCase</code> 风格，而后端（尤其是 Python）则遵循 PEP 8 风格，即 <code>snake_case</code>。为了在前后端之间保持一致性，我们可以使用 Pydantic 这个模块来自动转换和映射命名风格。本文将介绍如何使用 Pydantic 统一 Python 后端和 RESTful API 的命名规范，并在 <strong>GET</strong> 和 <strong>POST</strong> 请求中实现参数和请求体的命名统一。<h3 id=1-tong-yi-ming-ming-gui-fan-de-bi-yao-xing>1. <strong>统一命名规范的必要性</strong></h3><p>通常情况下：<ul><li><strong>前端</strong>：JavaScript 和 TypeScript 的社区更倾向于使用 <code>camelCase</code>，因为这是 JavaScript 的命名约定。<li><strong>后端</strong>：Python 更倾向于使用 <code>snake_case</code>，这是 PEP 8 风格指南的推荐。</ul><p>这种命名风格上的差异，往往会导致前后端之间的协作复杂化。为了确保规范性和一致性，我们可以通过以下方式来进行处理：<ul><li><strong>前端</strong>：保持 <code>camelCase</code> 风格的参数。<li><strong>后端</strong>：使用 <code>snake_case</code> 风格的参数，并且能够自动转换成前端使用的命名风格。</ul><h3 id=2-shi-yong-pydantic-shi-xian-ming-ming-gui-fan-hua>2. <strong>使用 Pydantic 实现命名规范化</strong></h3><p>Pydantic 是一个非常强大的 Python 数据验证和序列化工具。通过 Pydantic，我们可以灵活地定义数据模型，并使用 <code>alias_generator</code> 和 <code>populate_by_name</code> 来自动处理命名风格转换。<h4 id=shi-xian-fang-shi>实现方式：</h4><ul><li><strong>GET 请求</strong>：使用 <code>Query</code> 接收查询参数，并通过 <code>alias</code> 映射 <code>camelCase</code> 参数到后端使用的 <code>snake_case</code> 参数。<li><strong>POST 请求</strong>：使用 Pydantic 模型，并通过 <code>alias_generator</code> 和 <code>to_camel</code> 将请求体参数从 <code>snake_case</code> 转换为 <code>camelCase</code>。</ul><h3 id=3-get-qing-qiu-zhong-de-can-shu-zhuan-huan>3. <strong>GET 请求中的参数转换</strong></h3><p>在 <strong>GET</strong> 请求中，参数通常通过查询字符串传递。我们可以通过 Pydantic 的 <code>Query</code> 来接收查询参数，并在其中使用 <code>alias</code> 将 <code>camelCase</code> 转换为 <code>snake_case</code>，从而确保后端遵循 Python 的命名约定。<h4 id=shi-li-dai-ma-get-qing-qiu-zhong-de-alias-zhuan-huan>示例代码：GET 请求中的 <code>alias</code> 转换</h4><pre class=language-python data-lang=python><code class=language-python data-lang=python>from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/")
async def get_item(
    item_id: int = Query(..., alias="itemId"),  # 'itemId' 是前端传递的参数
    q: str | None = Query(None, alias="searchQuery")  # 'searchQuery' 是前端传递的参数
):
    return {"item_id": item_id, "q": q}
</code></pre><h3 id=dai-ma-jie-shi>代码解释：</h3><ul><li><strong>前端使用 <code>camelCase</code></strong>：前端传递的查询参数是 <code>itemId</code> 和 <code>searchQuery</code>。<li><strong>后端使用 <code>snake_case</code></strong>：后端处理时，自动将查询参数映射到 <code>item_id</code> 和 <code>q</code>，符合 PEP 8 规范。</ul><h3 id=4-post-qing-qiu-zhong-de-qing-qiu-ti-zhuan-huan>4. <strong>POST 请求中的请求体转换</strong></h3><p>对于 <strong>POST</strong> 请求，我们可以使用 Pydantic 模型，在后端使用 <code>snake_case</code> 参数，但通过 <code>alias_generator</code> 和 <code>to_camel</code> 来支持前端传递的 <code>camelCase</code> 参数。<h4 id=shi-li-dai-ma-post-qing-qiu-zhong-de-qing-qiu-ti-zhuan-huan>示例代码：POST 请求中的请求体转换</h4><pre class=language-python data-lang=python><code class=language-python data-lang=python>from fastapi import FastAPI
from pydantic import BaseModel, Field
from pydantic.alias_generators import to_camel

app = FastAPI()

class Item(BaseModel):
    item_id: int = Field(..., description="The ID of the item to get")
    q: str | None = Field(None, max_length=50, description="A search query")

    class Config:
        alias_generator = to_camel  # 使用 to_camel 来转换字段名
        populate_by_name = True  # 允许使用字段名称而不是别名

@app.post("/items/")
async def create_item(item: Item):
    return {"item_id": item.item_id, "q": item.q}
</code></pre><h3 id=dai-ma-jie-shi-1>代码解释：</h3><ul><li><strong><code>alias_generator = to_camel</code></strong>：Pydantic 提供了一个 <code>to_camel</code> 别名生成器，自动将字段名从 <code>snake_case</code> 转换为 <code>camelCase</code>。<li><strong><code>populate_by_name = True</code></strong>：允许通过字段名称而不是别名来填充字段，这样就可以支持前端使用 <code>camelCase</code> 参数名。</ul><h3 id=5-ce-shi-he-yun-xing>5. <strong>测试和运行</strong></h3><p>启动 FastAPI 应用后，我们可以通过以下 URL 来测试：<h4 id=get-qing-qiu>GET 请求：</h4><pre class=language-json data-lang=json><code class=language-json data-lang=json>http://127.0.0.1:8000/items/?itemId=42&searchQuery=example
</code></pre><p>响应将是：<pre class=language-json data-lang=json><code class=language-json data-lang=json>{
  "item_id": 42,
  "q": "example"
}
</code></pre><p><img alt=image-20250205174439243 src=https://fullstackjam-1257718633.cos.ap-nanjing.myqcloud.com/imgs/202502051744911.png><h4 id=post-qing-qiu>POST 请求：</h4><p>请求：<pre class=language-json data-lang=json><code class=language-json data-lang=json>POST http://127.0.0.1:8000/items/
Content-Type: application/json

{
  "itemId": 42,
  "searchQuery": "example"
}
</code></pre><p>响应将是：<pre class=language-json data-lang=json><code class=language-json data-lang=json>{
  "item_id": 42,
  "q": "example"
}
</code></pre><p><img alt=image-20250205174556012 src=https://fullstackjam-1257718633.cos.ap-nanjing.myqcloud.com/imgs/202502051745453.png><h3 id=6-zong-jie>6. <strong>总结</strong></h3><p>通过使用 Pydantic 的 <code>alias</code> 和 <code>alias_generator</code> 功能，我们可以高效地实现以下目标：<ol><li><strong>统一命名规范</strong>：确保前后端之间的命名风格一致，前端使用 <code>camelCase</code>，后端使用 <code>snake_case</code>，从而避免了不同风格带来的问题。<li><strong>遵循 PEP 8 标准</strong>：后端代码保持符合 Python 的 PEP 8 风格指南，提升代码的可读性和一致性。<li><strong>无缝协作</strong>：通过 Pydantic 自动转换功能，前后端能够轻松对接，无需手动转换参数名，从而提高开发效率并减少出错的风险。</ol></div><div id=comments-issue-id style=display:none>5</div><style>#comment-header,#comment-list>li{margin:1em auto}#comment-avatar,#comment-tip{margin:auto .2em}#comment-action-avatar,#comment-avatar{width:1em;height:1em}#comment-action-info>*,#comment-action-input>*,#comment-info>*{display:inline-block;vertical-align:middle}#comment-header{font-size:1.6em;font-weight:700;line-height:1.6em}#comment-tip{font-style:italic}#comment-list{list-style:none;padding:0}#comment-action-author,#comment-author{font-weight:700;margin:auto .4em}#comment-datetime{font-size:.8em;font-style:italic}#comment-body{margin:auto 1.8em}#comment-action-info>*{margin:1em .2em}#comment-action-input{height:2em;width:100%;margin:1em auto}#comment-action-input>*{height:100%;margin:0 .2em}#comment-action-textarea{width:calc(100% - 8em)}#comment-action-post{width:6em}#comment-action-login{margin:1em .3em}</style><ol id=comment-list></ol><div id=comment-action></div><script>const y=e=>{var t=/\\([\\\|`*_{}\[\]()#+\-~])/g,n=/\n *&gt; *([^]*?)(?=(\n|$){2})/g,i=/\n( *)(?:[*\-+]|((\d+)|([a-z])|[A-Z])[.)]) +([^]*?)(?=(\n|$){2})/g,o=/(^|[^A-Za-z\d\\])(([*_])|(~)|(\^)|(--)|(\+\+)|`)(\2?)([^<]*?)\2\8(?!\2)(?=\W|_|$)/g,a=/^.*\n( *\|( *:?-+:?-+:? *\|)* *\n|)/,c=/.*\n/g,m=/\||(.*?[^\\])\|/g;const l=(t,n)=>{e=e.replace(t,n)},d=(e,t)=>"<"+e+">"+t+"</"+e+">",r=e=>e.replace(n,((e,t)=>d("blockquote",r(u(t.replace(/^ *&gt; */gm,"")))))),s=e=>e.replace(i,((e,t,n,i,o,a)=>(e=d("li",u(a.split(RegExp("\n ?"+t+"(?:(?:\\d+|[a-zA-Z])[.)]|[*\\-+]) +","g")).map(s).join("</li><li>"))),"\n"+(n?'<ol start="'+(i?n+'">':parseInt(n,36)-9+'" style="list-style-type:'+(o?"low":"upp")+'er-alpha">')+e+"</ol>":d("ul",e))))),u=e=>e.replace(o,((e,t,n,i,o,a,c,m,l,r)=>t+d(i?l?"strong":"em":o?l?"s":"sub":a?"sup":c?"small":m?"big":"code",u(r))));var p=[],h=0;return e="\n"+e+"\n",l(/</g,"&lt;"),l(/>/g,"&gt;"),l(/\t|\r|\uf8ff/g,"  "),e=r(e),l(/^([*\-=_] *){3,}$/gm,"<hr/>"),e=s(e),l(/<\/(ol|ul)>\n\n<\1>/g,""),l(/\n((```|~~~).*\n?([^]*?)\n?\2|((    .*?\n)+))/g,((e,t,n,i,o)=>(p[--h]=d("pre",d("code",i||o.replace(/^    /gm,""))),h+""))),l(/((!?)\[(.*?)\]\((.*?)( ".*")?\)|\\([\\`*_{}\[\]()#+\-.!~]))/g,((e,n,i,o,a,c,m)=>(p[--h]=a?i?'<img src="'+a+'" alt="'+o+'"/>':'<a href="'+a+'">'+u(o).replace(t,"$1")+"</a>":m,h+""))),l(/&lt;(.*?)&gt;/g,((e,n)=>'<a href="'+n+'">'+u(n).replace(t,"$1")+"</a>")),l(/\n(( *\|.*?\| *\n)+)/g,((e,n)=>{var i=n.match(a)[1];return"\n"+d("table",n.replace(c,((e,n)=>e==i?"":d("tr",e.replace(m,((e,o,a)=>a?d(i&&!n?"th":"td",u(o||"").replace(t,"$1")):""))))))})),l(/(?=^|>|\n)([>\s]*?)(#{1,6}) (.*?)( #*)? *(?=\n|$)/g,((e,n,i,o)=>n+d("h"+i.length,u(o).replace(t,"$1")))),l(/(?=^|>|\n)\s*\n+([^<]+?)\n+\s*(?=\n|<|$)/g,((e,n)=>d("p",u(n).replace(t,"$1")))),l(/-\d+\uf8ff/g,(e=>p[parseInt(e,10)])),e.trim()},f=e=>{let t=t=>e.next(t),n=t=>e.throw(t);return new Promise(((i,o)=>{let a=e=>{e.done?i(e.value):Promise.resolve(e.value).then(t,n).then(a,o)};a(e.next())}))};let g;const m=document.getElementById("comments-issue-id").innerText,n=new URL(window.location.href);let q,p=n.searchParams.get("github_access_token");p&&(document.cookie=`github_access_token=${p};Path=/;Secure;SameSite=Strict`,n.searchParams.delete("github_access_token"),window.location.replace(n)),null!=p||(p=null==(q=document.cookie.split(";").find((e=>e.trim().startsWith("github_access_token="))))?void 0:q.trim().substring(20));const r=()=>{document.cookie="github_access_token=;expires=Thu, 01 Jan 1970 00:00:00 GMT;Path=/;Secure;SameSite=Strict",p=null},t=()=>f(function*(){var e;let n;if(g=JSON.parse(null!=(n=null==(e=document.getElementById("comments-addition"))?void 0:e.innerText)?n:"[]"),p){if(200!==(e=yield fetch(`https://comments.fullstackjam.dev/comments?issue_id=${m}&github_access_token=${p}`,{method:"GET"})).status)return r(),yield t()}else e=yield fetch(`https://comments.fullstackjam.dev/comments?issue_id=${m}`,{method:"GET"});200===e.status&&(g=g.concat(yield e.json()))}()),u=()=>{g.sort(((e,t)=>new Date(e.created_at).getTime()-new Date(t.created_at).getTime()));let e=document.getElementById("comment-list");e.innerHTML="";var t=document.createElement("div");for(t.id="comment-header",t.innerText="Comments",e.appendChild(t),0===g.length&&((t=document.createElement("div")).id="comment-tip",t.innerText="No comment yet",e.appendChild(t)),t=0;t<g.length;t++){let o=document.createElement("li");var n=document.createElement("div");n.id="comment-info";var i=document.createElement("img");i.id="comment-avatar",i.src=g[t].user.avatar_url,n.appendChild(i),(i=document.createElement("a")).id="comment-author",i.innerText=g[t].user.login,g[t].user.html_url&&(i.href=g[t].user.html_url),n.appendChild(i),(i=document.createElement("div")).id="comment-datetime",i.innerText=new Date(g[t].created_at).toLocaleString(),n.appendChild(i),o.appendChild(n),(n=document.createElement("div")).id="comment-body",n.innerHTML=y(g[t].body),o.appendChild(n),e.appendChild(o)}},v=()=>f(function*(){let e=document.getElementById("comment-action");e.innerHTML="";var n=document.createElement("div");if(n.id="comment-header",n.innerText="Leave a comment",e.appendChild(n),p){if(200===(n=yield fetch(`https://comments.fullstackjam.dev/userinfo?github_access_token=${p}`,{method:"GET"})).status){n=yield n.json();let o=document.createElement("div");o.id="comment-action-info";var i=document.createElement("img");i.id="comment-action-avatar",i.src=n.avatar_url,o.appendChild(i),(i=document.createElement("a")).id="comment-action-author",i.innerText=n.login,i.href=n.html_url,o.appendChild(i);let a=document.createElement("button");a.id="comment-action-logout",a.innerText="Logout",a.addEventListener("click",(()=>{r(),v()})),o.appendChild(a),e.appendChild(o),(n=document.createElement("div")).id="comment-tip",n.innerText="Before posting a comment, consider if it's relevant, sensible, and kind. Would it bother you if someone else wrote it?",e.appendChild(n),(n=document.createElement("div")).id="comment-action-input";let c=document.createElement("textarea");c.id="comment-action-textarea",c.placeholder="Leave a comment",n.appendChild(c);let l=document.createElement("button");return l.id="comment-action-post",l.innerText="Comment",l.addEventListener("click",(()=>f(function*(){a.disabled=!0,c.disabled=!0,l.disabled=!0;let e=c.value.trim();0!==e.length&&(201===(yield fetch(`https://comments.fullstackjam.dev/comments?issue_id=${m}&github_access_token=${p}`,{method:"POST",body:JSON.stringify({body:e})})).status?t().then((()=>u())).then((()=>v())):(r(),yield v(),window.alert("Failed to post comment")))}()))),n.appendChild(l),void e.appendChild(n)}r()}(n=document.createElement("div")).id="comment-tip",n.innerText="Clicking the login button means you agree to use cookies to store your GitHub Access Token",e.appendChild(n),(n=document.createElement("button")).id="comment-action-login",n.innerText="Login with GitHub",n.addEventListener("click",(()=>window.location.replace(`https://comments.fullstackjam.dev/login?redirect_uri=${window.location.href}`))),e.appendChild(n)}());t().then((()=>u())).then((()=>v()))</script></div>