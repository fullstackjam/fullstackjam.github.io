<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=#000000 id=color_chrome name=theme-color><meta content=#000000 id=color_safari name=apple-mobile-web-app-status-bar-style><meta content="Jam's Blog" name=description><link rel="Shortcut Icon" href=https://blog.fullstackjam.dev/favicon.svg><link href=https://blog.fullstackjam.dev/favicon.svg rel=Bootmark><link title="Jam's Blog" href=https://blog.fullstackjam.dev/rss.xml rel=alternate type=application/rss+xml><style>#title,body{line-height:1.6em}body{background:#000;color:#00c000;font-size:1.2em}#container{margin:2.4em auto;width:72%}#header{text-align:center}#header>a{font-size:.96em;margin:auto 1em}#title{font-size:1.6em;font-weight:700;margin:1em auto}#date{font-style:italic}#list>li{margin:.8em auto;list-style:disc}img{max-width:100%}a{color:inherit;text-decoration:none}#content a,a:hover{text-decoration:underline}pre{padding:1em;overflow:auto;background:#1b1d16}:not(pre) >code{padding:.2em;background:#1b1d16;overflow:auto}blockquote{padding:0 1em;margin:0;border-left:.25em solid #212121}@media (max-width:600px){#container{width:88%}#header>a{margin:auto .3em}}</style><title>Linux Basics and System Startup - Jam's Blog</title><body><div id=header><a href=https://blog.fullstackjam.dev>Jam's Blog</a><a href=https://blog.fullstackjam.dev/about/>About</a><a href=https://blog.fullstackjam.dev/friends/>Friends</a><a href=https://blog.fullstackjam.dev/projects/>Projects</a></div><div id=container><a href=https://blog.fullstackjam.dev/2022/linux-basics-and-system-startup/ id=title>Linux Basics and System Startup</a><div id=date>2022-04-17</div><div id=content><p>In this post, you will learn：<ul><li>Identify Linux filesystems.<li>Identify the differences between partitions and filesystems.<li>Describe the boot process.</ul><h2 id=the-boot-process>The Boot Process</h2><p>The Linux boot process is the procedure for initializing the system. It consists of everything that happens from when the computer power is first switched on until the user interface is fully operational.<div align=center><img src=https://fullstackjam-1257718633.cos.ap-nanjing.myqcloud.com/imgs/202204171220003.jpeg></div><h3 id=bios-the-first-step>BIOS - The First Step</h3><p>Starting an x86-based Linux system involves a number of steps. When the computer is powered on, the <strong>B</strong>asic <strong>I</strong>nput/<strong>O</strong>utput <strong>S</strong>ystem (<strong>BIOS</strong>) initializes the hardware, including the screen and keyboard, and tests the main memory. This process is also called <strong>POST</strong> (<strong>P</strong>ower <strong>O</strong>n <strong>S</strong>elf <strong>T</strong>est).<div align=center><img src=https://fullstackjam-1257718633.cos.ap-nanjing.myqcloud.com/imgs/202204171222021.jpeg></div><p>The BIOS software is stored on a ROM chip on the motherboard. After this, the remainder of the boot process is controlled by the operating system (OS).<h3 id=master-boot-record-mbr-and-boot-loader>Master Boot Record (MBR) and Boot Loader</h3><p>Once the <strong>POST</strong> is completed, the system control passed from the <strong>BIOS</strong> to the <strong>boot loader</strong>. The boot loader is usually stored on one of the hard disks in the system, either in the boot sector (for traditional BIOS/MBR systems) or the <strong>EFI</strong> partition (for more recent (Unified) <strong>E</strong>xtensible <strong>F</strong>irmware <strong>I</strong>nterface or <strong>EFI/UEFI</strong> systems). Up to this stage, the machine does not access any mass storage media. Thereafter, information on date, time, and the most important peripherals(外部设备) are loaded from the <a href=https://zh.wikipedia.org/wiki/%E4%BA%92%E8%A3%9C%E5%BC%8F%E9%87%91%E5%B1%AC%E6%B0%A7%E5%8C%96%E7%89%A9%E5%8D%8A%E5%B0%8E%E9%AB%94>CMOS</a> values (after a technology used for the battery-powered memory store which allows the system to keep track of the date and time even when it is powered off).<p>A number of boot loaders exist for Linux; the most common ones are <strong>GRUB</strong> (for <strong>GR</strong>and <strong>U</strong>nified <strong>B</strong>oot loader), <strong>ISOLINUX</strong> (for booting from removable media), and <strong>DAS U-Boot</strong> (for booting on embedded devices/appliances). Most Linux boot loaders can present a user interface for choosing alternative options for booting Linux, and even other operating systems that might be installed. When booting Linux, the boot loader is responsible for loading the kernel image and the initial RAM disk or filesystem (which contains some critical files and device drivers needed to start the system) into memory.<div align=center><img src=https://fullstackjam-1257718633.cos.ap-nanjing.myqcloud.com/imgs/202204171226587.jpeg></div><h3 id=boot-loader-in-action>Boot Loader in Action</h3><p>The boot loader has two distinct stages:<p>For systems using the BIOS/MBR method, the boot loader resides at the first sector of the hard disk, also known as the <strong>M</strong>aster <strong>B</strong>oot <strong>R</strong>ecord (<strong>MBR</strong>). The size of the MBR is just 512 bytes. In this stage, the boot loader examines the <strong>partition table</strong> and finds a bootable partition. Once it finds a bootable partition, it then searches for the second stage boot loader, for example GRUB, and loads it into RAM (Random Access Memory). For systems using the EFI/UEFI method, UEFI firmware reads its Boot Manager data to determine which UEFI application is to be launched and from where (i.e. from which disk and partition the EFI partition can be found). The firmware then launches the UEFI application, for example GRUB, as defined in the boot entry in the firmware's boot manager. This procedure is more complicated, but more versatile(多用途) than the older MBR methods.<div align=center><img src=https://fullstackjam-1257718633.cos.ap-nanjing.myqcloud.com/imgs/202204171229699.jpeg></div><p>The second stage boot loader resides under <strong>/boot</strong>. A splash screen is displayed, which allows us to choose which operating system (OS) to boot. After choosing the OS, the boot loader loads the kernel of the selected operating system into RAM and passes control to it. Kernels are almost always compressed, so its first job is to uncompress itself. After this, it will check and analyze the system hardware and initialize any hardware device drivers built into the kernel.<h3 id=initial-ram-disk>Initial RAM Disk</h3><p>The <strong>initramfs</strong> filesystem image contains programs and binary files that perform all actions needed to mount the proper root filesystem, like providing kernel functionality for the needed filesystem and device drivers for mass storage controllers with a facility called <strong>udev</strong> (for <strong>u</strong>ser <strong>dev</strong>ice), which is responsible for figuring out which devices are present, locating the device drivers they need to operate properly, and loading them. After the root filesystem has been found, it is checked for errors and mounted.<p>The <strong>mount</strong> program instructs the operating system that a filesystem is ready for use, and associates it with a particular point in the overall hierarchy of the filesystem (the <strong>mount point</strong>). If this is successful, the initramfs is cleared from RAM and the init program on the root filesystem (<strong>/sbin/init</strong>) is executed.<p><strong>init</strong> handles the mounting and pivoting over to the final real root filesystem. If special hardware drivers are needed before the mass storage can be accessed, they must be in the initramfs image.<div align=center><img src=https://fullstackjam-1257718633.cos.ap-nanjing.myqcloud.com/imgs/202204171235264.jpeg></div><h3 id=text-mode-login>Text-Mode Login</h3><p>Near the end of the boot process, <strong>init</strong> starts a number of text-mode login prompts. These enable you to type your username, followed by your password, and to eventually get a command shell. However, if you are running a system with a graphical login interface, you will not see these at first.<p>Usually, the default command shell is <strong>bash</strong> (the <strong>GNU</strong> <strong>B</strong>ourne <strong>A</strong>gain <strong>Sh</strong>ell), but there are a number of other advanced command shells available. The shell prints a text prompt, indicating it is ready to accept commands; after the user types the command and presses <strong>Enter</strong>, the command is executed, and another prompt is displayed after the command is done.<h2 id=kernel-init-and-services>Kernel, init and Services</h2><h3 id=the-linux-kernel>The Linux Kernel</h3><p>The boot loader loads both the <strong>kernel</strong> and an initial RAM–based file system (initramfs) into memory, so it can be used directly by the kernel.<div align=center><img src=https://fullstackjam-1257718633.cos.ap-nanjing.myqcloud.com/imgs/202204171238604.jpeg></div><p>When the kernel is loaded in RAM, it immediately initializes and configures the computer’s memory and also configures all the hardware attached to the system. This includes all processors, I/O subsystems, storage devices, etc. The kernel also loads some necessary user space applications.<h3 id=sbin-init-and-services>/sbin/init and Services</h3><p>Once the kernel has set up all its hardware and mounted the root filesystem, the kernel runs <strong>/sbin/init</strong>. This then becomes the initial process, which then starts other processes to get the system running. Most other processes on the system trace their origin ultimately to <strong>init</strong>; exceptions include the so-called kernel processes. These are started by the kernel directly, and their job is to manage internal operating system details.<p>Besides starting the system, <strong>init</strong> is responsible for keeping the system running and for shutting it down cleanly. One of its responsibilities is to act when necessary as a manager for all non-kernel processes; it cleans up after them upon completion, and restarts user login services as needed when users log in and out, and does the same for other background system services.<div align=center><img src=https://fullstackjam-1257718633.cos.ap-nanjing.myqcloud.com/imgs/202204171253688.jpeg></div><p>Traditionally, this process startup was done using conventions that date back to the 1980s and the System V variety of UNIX. This serial process had the system passing through a sequence of <strong>runlevels</strong> containing collections of scripts that start and stop services. Each runlevel supported a different mode of running the system. Within each runlevel, individual services could be set to run, or to be shut down if running.<p>However, all major distributions have moved away from this sequential runlevel method of system initialization, although they usually emulate many System V utilities for compatibility purposes. Next, we discuss the new methods, of which <strong>systemd</strong> has become dominant.<h3 id=startup-alternatives>Startup Alternatives</h3><p><strong>SysVinit</strong> viewed things as a serial process, divided into a series of sequential stages. Each stage required completion before the next could proceed. Thus, startup did not easily take advantage of the *<strong>parallel processing*</strong> that could be done on multiple processors or cores.<h3 id=systemd-features>systemd Features</h3><p>Systems with <strong>systemd</strong> start up faster than those with earlier <strong>init</strong> methods. This is largely because it replaces a serialized set of steps with aggressive parallelization techniques, which permits multiple services to be initiated simultaneously.<p>Complicated startup shell scripts are replaced with simpler configuration files, which enumerate what has to be done before a service is started, how to execute service startup, and what conditions the service should indicate have been accomplished when startup is finished. One thing to note is that <strong>/sbin/init</strong> now just points to <strong>lib/systemd/systemd</strong>; i.e. <strong>systemd</strong> takes over the <strong>init</strong> process.<p>One <strong>systemd</strong> command (<strong>systemctl</strong>) is used for most basic tasks. While we have not yet talked about working at the command line, here is a brief listing of its use:<ul><li><p>Starting, stopping, restarting a service (using <strong>httpd</strong>, the Apache web server, as an example) on a currently running system: <code>$ sudo systemctl start|stop|restart httpd.service</code></p><li><p>Enabling or disabling a system service from starting up at system boot: <code>$ sudo systemctl enable|disable httpd.service</code></p></ul><p>In most cases, the <strong>.service</strong> can be omitted. There are many technical differences with older methods that lie beyond the scope of our discussion.<h2 id=linux-filesystem-basics>Linux Filesystem Basics</h2><h3 id=linux-filesystems>Linux Filesystems</h3><p>Different types of filesystems supported by Linux:<ul><li>Conventional disk filesystems: <strong>ext3</strong>, <strong>ext4</strong>, <strong>XFS</strong>, <strong>Btrfs</strong>, <strong>JFS</strong>, <strong>NTFS</strong>, <strong>vfat</strong>, <strong>exfat</strong>, etc.<li>Flash storage filesystems: <strong>ubifs</strong>, <strong>jffs2</strong>, <strong>yaffs</strong>, etc.<li>Database filesystems<li>Special purpose filesystems: <strong>procfs</strong>, <strong>sysfs</strong>, <strong>tmpfs</strong>, <strong>squashfs</strong>, <strong>debugfs</strong>, <strong>fuse</strong>, etc.</ul><h3 id=partitions-and-filesystems>Partitions and Filesystems</h3><p>A <strong>partition</strong> is a physically contiguous section of a disk, or what appears to be so in some advanced setups.<p>A <strong>filesystem</strong> is a method of storing/finding files on a hard disk (usually in a partition).<p>A comparison between filesystems in Windows and Linux is given in the accompanying table:<table><thead><tr><th><th><strong>Windows</strong><th><strong>Linux</strong><tbody><tr><td>Partition<td>Disk1<td><strong>/dev/sda1</strong><tr><td>Filesystem Type<td>NTFS/VFAT<td>EXT3/EXT4/XFS/BTRFS...<tr><td>Mounting Parameters<td>DriveLetter<td>MountPoint<tr><td>Base Folder (where OS is stored)<td>C:\<td>/</table><h3 id=the-filesystem-hierarchy-standard>The Filesystem Hierarchy Standard</h3><p>Linux uses the <code>/</code> character to separate paths (unlike Windows, which uses <code>\</code>), and does not have drive letters. Multiple drives and/or partitions are mounted as directories in the single filesystem. Removable media such as USB drives and CDs and DVDs will show up as mounted at <strong>/run/media/yourusername/disklabel</strong> for recent Linux systems, or under <strong>/media</strong> for older distributions. For example, if your username is <strong>student</strong> a USB pen drive labeled FEDORA might end up being found at <strong>/run/media/student/FEDORA</strong>, and a file <strong>README.txt</strong> on that disc would be at <strong>/run/media/student/FEDORA/README.txt</strong>.</div><div id=comments-issue-id style=display:none>1</div><style>#comment-header,#comment-list>li{margin:1em auto}#comment-avatar,#comment-tip{margin:auto .2em}#comment-action-avatar,#comment-avatar{width:1em;height:1em}#comment-action-info>*,#comment-action-input>*,#comment-info>*{display:inline-block;vertical-align:middle}#comment-header{font-size:1.6em;font-weight:700;line-height:1.6em}#comment-tip{font-style:italic}#comment-list{list-style:none;padding:0}#comment-action-author,#comment-author{font-weight:700;margin:auto .4em}#comment-datetime{font-size:.8em;font-style:italic}#comment-body{margin:auto 1.8em}#comment-action-info>*{margin:1em .2em}#comment-action-input{height:2em;width:100%;margin:1em auto}#comment-action-input>*{height:100%;margin:0 .2em}#comment-action-textarea{width:calc(100% - 8em)}#comment-action-post{width:6em}#comment-action-login{margin:1em .3em}</style><ol id=comment-list></ol><div id=comment-action></div><script>const y=e=>{var t=/\\([\\\|`*_{}\[\]()#+\-~])/g,n=/\n *&gt; *([^]*?)(?=(\n|$){2})/g,i=/\n( *)(?:[*\-+]|((\d+)|([a-z])|[A-Z])[.)]) +([^]*?)(?=(\n|$){2})/g,o=/(^|[^A-Za-z\d\\])(([*_])|(~)|(\^)|(--)|(\+\+)|`)(\2?)([^<]*?)\2\8(?!\2)(?=\W|_|$)/g,a=/^.*\n( *\|( *:?-+:?-+:? *\|)* *\n|)/,c=/.*\n/g,m=/\||(.*?[^\\])\|/g;const l=(t,n)=>{e=e.replace(t,n)},d=(e,t)=>"<"+e+">"+t+"</"+e+">",r=e=>e.replace(n,((e,t)=>d("blockquote",r(u(t.replace(/^ *&gt; */gm,"")))))),s=e=>e.replace(i,((e,t,n,i,o,a)=>(e=d("li",u(a.split(RegExp("\n ?"+t+"(?:(?:\\d+|[a-zA-Z])[.)]|[*\\-+]) +","g")).map(s).join("</li><li>"))),"\n"+(n?'<ol start="'+(i?n+'">':parseInt(n,36)-9+'" style="list-style-type:'+(o?"low":"upp")+'er-alpha">')+e+"</ol>":d("ul",e))))),u=e=>e.replace(o,((e,t,n,i,o,a,c,m,l,r)=>t+d(i?l?"strong":"em":o?l?"s":"sub":a?"sup":c?"small":m?"big":"code",u(r))));var p=[],h=0;return e="\n"+e+"\n",l(/</g,"&lt;"),l(/>/g,"&gt;"),l(/\t|\r|\uf8ff/g,"  "),e=r(e),l(/^([*\-=_] *){3,}$/gm,"<hr/>"),e=s(e),l(/<\/(ol|ul)>\n\n<\1>/g,""),l(/\n((```|~~~).*\n?([^]*?)\n?\2|((    .*?\n)+))/g,((e,t,n,i,o)=>(p[--h]=d("pre",d("code",i||o.replace(/^    /gm,""))),h+""))),l(/((!?)\[(.*?)\]\((.*?)( ".*")?\)|\\([\\`*_{}\[\]()#+\-.!~]))/g,((e,n,i,o,a,c,m)=>(p[--h]=a?i?'<img src="'+a+'" alt="'+o+'"/>':'<a href="'+a+'">'+u(o).replace(t,"$1")+"</a>":m,h+""))),l(/&lt;(.*?)&gt;/g,((e,n)=>'<a href="'+n+'">'+u(n).replace(t,"$1")+"</a>")),l(/\n(( *\|.*?\| *\n)+)/g,((e,n)=>{var i=n.match(a)[1];return"\n"+d("table",n.replace(c,((e,n)=>e==i?"":d("tr",e.replace(m,((e,o,a)=>a?d(i&&!n?"th":"td",u(o||"").replace(t,"$1")):""))))))})),l(/(?=^|>|\n)([>\s]*?)(#{1,6}) (.*?)( #*)? *(?=\n|$)/g,((e,n,i,o)=>n+d("h"+i.length,u(o).replace(t,"$1")))),l(/(?=^|>|\n)\s*\n+([^<]+?)\n+\s*(?=\n|<|$)/g,((e,n)=>d("p",u(n).replace(t,"$1")))),l(/-\d+\uf8ff/g,(e=>p[parseInt(e,10)])),e.trim()},f=e=>{let t=t=>e.next(t),n=t=>e.throw(t);return new Promise(((i,o)=>{let a=e=>{e.done?i(e.value):Promise.resolve(e.value).then(t,n).then(a,o)};a(e.next())}))};let g;const m=document.getElementById("comments-issue-id").innerText,n=new URL(window.location.href);let q,p=n.searchParams.get("github_access_token");p&&(document.cookie=`github_access_token=${p};Path=/;Secure;SameSite=Strict`,n.searchParams.delete("github_access_token"),window.location.replace(n)),null!=p||(p=null==(q=document.cookie.split(";").find((e=>e.trim().startsWith("github_access_token="))))?void 0:q.trim().substring(20));const r=()=>{document.cookie="github_access_token=;expires=Thu, 01 Jan 1970 00:00:00 GMT;Path=/;Secure;SameSite=Strict",p=null},t=()=>f(function*(){var e;let n;if(g=JSON.parse(null!=(n=null==(e=document.getElementById("comments-addition"))?void 0:e.innerText)?n:"[]"),p){if(200!==(e=yield fetch(`https://comments.fullstackjam.dev/comments?issue_id=${m}&github_access_token=${p}`,{method:"GET"})).status)return r(),yield t()}else e=yield fetch(`https://comments.fullstackjam.dev/comments?issue_id=${m}`,{method:"GET"});200===e.status&&(g=g.concat(yield e.json()))}()),u=()=>{g.sort(((e,t)=>new Date(e.created_at).getTime()-new Date(t.created_at).getTime()));let e=document.getElementById("comment-list");e.innerHTML="";var t=document.createElement("div");for(t.id="comment-header",t.innerText="Comments",e.appendChild(t),0===g.length&&((t=document.createElement("div")).id="comment-tip",t.innerText="No comment yet",e.appendChild(t)),t=0;t<g.length;t++){let o=document.createElement("li");var n=document.createElement("div");n.id="comment-info";var i=document.createElement("img");i.id="comment-avatar",i.src=g[t].user.avatar_url,n.appendChild(i),(i=document.createElement("a")).id="comment-author",i.innerText=g[t].user.login,g[t].user.html_url&&(i.href=g[t].user.html_url),n.appendChild(i),(i=document.createElement("div")).id="comment-datetime",i.innerText=new Date(g[t].created_at).toLocaleString(),n.appendChild(i),o.appendChild(n),(n=document.createElement("div")).id="comment-body",n.innerHTML=y(g[t].body),o.appendChild(n),e.appendChild(o)}},v=()=>f(function*(){let e=document.getElementById("comment-action");e.innerHTML="";var n=document.createElement("div");if(n.id="comment-header",n.innerText="Leave a comment",e.appendChild(n),p){if(200===(n=yield fetch(`https://comments.fullstackjam.dev/userinfo?github_access_token=${p}`,{method:"GET"})).status){n=yield n.json();let o=document.createElement("div");o.id="comment-action-info";var i=document.createElement("img");i.id="comment-action-avatar",i.src=n.avatar_url,o.appendChild(i),(i=document.createElement("a")).id="comment-action-author",i.innerText=n.login,i.href=n.html_url,o.appendChild(i);let a=document.createElement("button");a.id="comment-action-logout",a.innerText="Logout",a.addEventListener("click",(()=>{r(),v()})),o.appendChild(a),e.appendChild(o),(n=document.createElement("div")).id="comment-tip",n.innerText="Before posting a comment, consider if it's relevant, sensible, and kind. Would it bother you if someone else wrote it?",e.appendChild(n),(n=document.createElement("div")).id="comment-action-input";let c=document.createElement("textarea");c.id="comment-action-textarea",c.placeholder="Leave a comment",n.appendChild(c);let l=document.createElement("button");return l.id="comment-action-post",l.innerText="Comment",l.addEventListener("click",(()=>f(function*(){a.disabled=!0,c.disabled=!0,l.disabled=!0;let e=c.value.trim();0!==e.length&&(201===(yield fetch(`https://comments.fullstackjam.dev/comments?issue_id=${m}&github_access_token=${p}`,{method:"POST",body:JSON.stringify({body:e})})).status?t().then((()=>u())).then((()=>v())):(r(),yield v(),window.alert("Failed to post comment")))}()))),n.appendChild(l),void e.appendChild(n)}r()}(n=document.createElement("div")).id="comment-tip",n.innerText="Clicking the login button means you agree to use cookies to store your GitHub Access Token",e.appendChild(n),(n=document.createElement("button")).id="comment-action-login",n.innerText="Login with GitHub",n.addEventListener("click",(()=>window.location.replace(`https://comments.fullstackjam.dev/login?redirect_uri=${window.location.href}`))),e.appendChild(n)}());t().then((()=>u())).then((()=>v()))</script></div>